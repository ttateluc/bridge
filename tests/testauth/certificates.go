package testauth

import (
	"crypto/rand"
	"crypto/x509"
	"encoding/hex"
	"encoding/json"
	"encoding/pem"
	"fmt"

	"golang.org/x/crypto/ed25519"
)

// client certificate for dave2@public.bdap.io.crt (testnet)
const dave2ClientPEMCert = (`
-----BEGIN CERTIFICATE-----
MIIBxDCCAXagAwIBAgIUO9dgPO6n1PFnvNhL+qcbfVKDTEswBQYDK2VwMFMxCzAJ
BgNVBAYTAlVTMSUwIwYDVQQKDBxEdWFsaXR5IEJsb2NrY2hhaW4gU29sdXRpb25z
MR0wGwYDVQQDDBRkYXZlM0BwdWJsaWMuYmRhcC5pbzAeFw0yMDA4MTgyMjUxMTRa
Fw0yMTA4MTgyMjUxMTRaMFMxCzAJBgNVBAYTAlVTMSUwIwYDVQQKDBxEdWFsaXR5
IEJsb2NrY2hhaW4gU29sdXRpb25zMR0wGwYDVQQDDBRkYXZlMkBwdWJsaWMuYmRh
cC5pbzAqMAUGAytlcAMhAPpNpSH/djBoiax5F9788CAZ51X+81z2Xd7cEIG2HsUt
o1wwWjAfBgNVHSMEGDAWgBQ/ySzT6XuGfd6GMv680yMskAOnkzAJBgNVHRMEAjAA
MAsGA1UdDwQEAwIE8DAfBgNVHREEGDAWghRkYXZlNEBwdWJsaWMuYmRhcC5pbzAF
BgMrZXADQQCBPl1YbNUcYSZWXbso9qVW/DMAPJwGbDos/5AXl+zOB7Gek4ylADql
O2KV/Hy3UKvRBTsDf4AcYlk/jC4ZIiM
M
-----END CERTIFICATE-----`)

const ed25519Cert = (`
-----BEGIN CERTIFICATE-----
MIIBojCCAVSgAwIBAgIHBa4wIlSc5jAFBgMrZXAwWDELMAkGA1UEBhMCVVMxJTAj
BgNVBAoMHER1YWxpdHkgQmxvY2tjaGFpbiBTb2x1dGlvbnMxIjAgBgNVBAMMGXRl
c3R1c2VyY2FAcHVibGljLmJkYXAuaW8wHhcNMjAwODMxMTc1NzIxWhcNMjEwOTAx
MTc1NzIxWjBXMQswCQYDVQQGEwJVUzElMCMGA1UECgwcRHVhbGl0eSBCbG9ja2No
YWluIFNvbHV0aW9uczEhMB8GA1UEAwwYdGVzdHVzZXIyQHB1YmxpYy5iZGFwLmlv
MCowBQYDK2VwAyEAFPMRC2sM6NQVBkfoiBqMxRJG5RX6arthvX33ugNmh+SjPjA8
MAwGA1UdEwEB/wQCMAAwCwYDVR0PBAQDAgTwMB8GA1UdIwQYMBaAFMQoUpMAxgKf
STZ4dhbUW4ak8rdOMAUGAytlcANBAGlWYx9yvpIi+SCfoDcl8v+JBpNQ+QbAgiTY
iap9DCHBxivXt+oSL4o33RxHNQk9X8dDDgbepa+3EdCdmH7q7wg=
-----END CERTIFICATE-----`)

const privateKey = (`MC4CAQAwBQYDK2VwBCIEINISzTP+u8qsBxQ+006wYwClaRQ2Kw96N5YQxn8DMzRb`)

const privateKeyHex = (`d212cd33febbcaac07143ed34eb06300a56914362b0f7a379610c67f0333345b14f3110b6b0ce8d4150647e8881a8cc51246e515fa6abb61bd7df7ba036687e4`)
const publicKeyHex = (`14f3110b6b0ce8d4150647e8881a8cc51246e515fa6abb61bd7df7ba036687e4`)

// CA certificate for dave3@public.bdap.io.crt (testnet)
const dave3CAPEMCert = (`
-----BEGIN CERTIFICATE-----
MIIBvTCCAW+gAwIBAgIGAXQDvkf8MAUGAytlcDBTMQswCQYDVQQGEwJVUzElMCMG
A1UECgwcRHVhbGl0eSBCbG9ja2NoYWluIFNvbHV0aW9uczEdMBsGA1UEAwwUZGF2
ZTNAcHVibGljLmJkYXAuaW8wHhcNMjAwODE4MjI0MzU2WhcNMzAwODE5MjI0MzU2
WjBTMQswCQYDVQQGEwJVUzElMCMGA1UECgwcRHVhbGl0eSBCbG9ja2NoYWluIFNv
bHV0aW9uczEdMBsGA1UEAwwUZGF2ZTNAcHVibGljLmJkYXAuaW8wKjAFBgMrZXAD
IQA2K6/JIdfUasALknLb8/XvNyJ+wPb1Cewq/8ewx5mNNqNjMGEwDwYDVR0TAQH/
BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFD/JLNPpe4Z93oYy/rzT
IyyQA6eTMB8GA1UdIwQYMBaAFD/JLNPpe4Z93oYy/rzTIyyQA6eTMAUGAytlcANB
AEZlTIRhgIIFzyje84gTuROONp5VWbdOMJFurJuupC5O/sjRQOsjHp+XY68SEeGB
N4ADDJdeGZO3JZdQdWfj2Q0=
-----END CERTIFICATE-----`)

// TestExistingSignature sign and verify digital signature test with hard coded keys
func TestExistingSignature() bool {
	message := []byte{0}
	publickey, err := hex.DecodeString(publicKeyHex)
	if err != nil {
		fmt.Println("Failed to decode hex pubkey:", err)
	}
	privkey, err := hex.DecodeString(privateKeyHex)
	if err != nil {
		fmt.Println("Failed to decode hex privkey:", err)
	}
	sig := ed25519.Sign(privkey, message)
	sigHex := make([]byte, hex.EncodedLen(len(sig)))
	hex.Encode(sigHex, sig)
	fmt.Println("Public Puykey Hex:", publicKeyHex)
	fmt.Println("Public PrivKey Hex:", privateKeyHex)
	fmt.Println("Signature Existing Keys:", string(sigHex))
	pass := ed25519.Verify(publickey, message, sig)
	fmt.Println("pass", pass)
	return pass
}

// TestNewKeySignature sign and verify digital signature test with newly generated keys
func TestNewKeySignature() bool {
	pubkey, privkey, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		fmt.Println("GenerateKey failed. ", err)
		return false
	}
	message := []byte{0}
	pubkeyHex := make([]byte, hex.EncodedLen(len(pubkey)))
	hex.Encode(pubkeyHex, pubkey)
	fmt.Println("Public Puykey Hex:", string(pubkeyHex))
	privkeyHex := make([]byte, hex.EncodedLen(len(privkey)))
	hex.Encode(privkeyHex, privkey)
	fmt.Println("Private PrivKey Hex:", string(privkeyHex))
	sig := ed25519.Sign(privkey, message)
	sigHex := make([]byte, hex.EncodedLen(len(sig)))
	hex.Encode(sigHex, sig)
	fmt.Println("Signature Hex1:", string(sigHex))
	pass := ed25519.Verify(pubkey, message, sig)
	fmt.Println("pass", pass)
	return pass
}

// TestCerts used to test Ed25519 certificates generated by dynamicd
func TestCerts() bool {
	block, _ := pem.Decode([]byte(ed25519Cert))
	clientCert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		fmt.Println("client cert Error", err)
		return false
	}
	fmt.Println("Client Certificate ExtKeyUsage", clientCert.ExtKeyUsage)
	fmt.Println("Client Certificate PublicKey", clientCert.PublicKey)
	clientPubKey, _ := json.Marshal(clientCert.PublicKey)
	clientPubkeyHex := make([]byte, hex.EncodedLen(len(clientPubKey)))
	hex.Encode(clientPubkeyHex, clientPubKey)
	fmt.Println("Client Certificate pubkey hex", string(clientPubkeyHex))
	fmt.Println("Client Certificate Subject", clientCert.Subject)
	fmt.Println("Client Certificate Issuer", clientCert.Issuer)
	fmt.Println("Client Certificate PublicKeyAlgorithm", clientCert.PublicKeyAlgorithm)
	fmt.Println("Client Certificate SerialNumber", clientCert.SerialNumber)
	fmt.Println("Client Certificate KeyUsage", clientCert.KeyUsage)
	block, _ = pem.Decode([]byte(dave3CAPEMCert))
	caCert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		fmt.Println("CA cert Error", err)
		return false
	}
	fmt.Println("CA Certificate ExtKeyUsage", caCert.ExtKeyUsage)
	fmt.Println("CA Certificate PublicKey", caCert.PublicKey)
	fmt.Println("CA Certificate Subject", caCert.Subject)
	fmt.Println("CA Certificate Issuer", caCert.Issuer)
	fmt.Println("CA Certificate PublicKeyAlgorithm", caCert.PublicKeyAlgorithm)
	fmt.Println("CA Certificate SerialNumber", caCert.SerialNumber)
	fmt.Println("CA Certificate KeyUsage", caCert.KeyUsage)
	return true
}
